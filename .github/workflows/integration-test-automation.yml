
name: Integration Test – Issue Automation

on:
  workflow_dispatch:

jobs:
  test-automation:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.ORG_WORKFLOW_TOKEN }}
      REPO: ${{ github.repository }}
      PROJECT_NUMBER: ${{ vars.PROJECT_NUMBER }}

    steps:
      - name: Setup environment
        run: |
          echo "Testing issue automation for $REPO"

      # Test 1: Dependency blocking
      - name: Create dependency issue D
        id: create_d
        run: |
          ISSUE_D=$(gh api repos/$REPO/issues \
            -f title="[TEST] Dependency Issue D" \
            -f body="Dependency for testing" \
            --jq '.number')
          echo "issue_d=$ISSUE_D" >> $GITHUB_OUTPUT
          echo "✓ Created dependency issue #$ISSUE_D"

      - name: Create task T with dependency on D
        id: create_t
        run: |
          ISSUE_D=${{ steps.create_d.outputs.issue_d }}

          BODY=$(cat <<EOF
          ### Description
          Task T for testing dependency automation

          ### Depends on
          - #$ISSUE_D
          EOF
          )

          ISSUE_T=$(gh api repos/$REPO/issues \
            -f title="[TEST] Task T with Dependency" \
            -f body="$BODY" \
            -f labels[]="type:task" \
            --jq '.number')
          echo "issue_t=$ISSUE_T" >> $GITHUB_OUTPUT
          echo "✓ Created task issue #$ISSUE_T depending on #$ISSUE_D"

      - name: Poll for status:blocked on T
        run: |
          ISSUE_T=${{ steps.create_t.outputs.issue_t }}
          MAX_WAIT=90
          ELAPSED=0
          FOUND=false

          echo "Polling for status:blocked on #$ISSUE_T (max ${MAX_WAIT}s)..."
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            LABELS=$(gh api repos/$REPO/issues/$ISSUE_T --jq '.labels[].name' | tr '\n' ' ')
            if echo "$LABELS" | grep -q "status:blocked"; then
              echo "✓ PASS: #$ISSUE_T has status:blocked after ${ELAPSED}s"
              FOUND=true
              break
            fi
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done

          if [ "$FOUND" = false ]; then
            echo "✗ FAIL: #$ISSUE_T did not get status:blocked within ${MAX_WAIT}s"
            echo "Current labels: $LABELS"
            exit 1
          fi

      - name: Close dependency D
        run: |
          ISSUE_D=${{ steps.create_d.outputs.issue_d }}
          gh api repos/$REPO/issues/$ISSUE_D -f state="closed" > /dev/null
          echo "✓ Closed dependency issue #$ISSUE_D"

      - name: Edit T to trigger automation
        run: |
          ISSUE_T=${{ steps.create_t.outputs.issue_t }}
          CURRENT_BODY=$(gh api repos/$REPO/issues/$ISSUE_T --jq '.body')
          gh api repos/$REPO/issues/$ISSUE_T -f body="$CURRENT_BODY " > /dev/null
          echo "✓ Edited #$ISSUE_T to trigger automation"

      - name: Poll for status:ready on T
        run: |
          ISSUE_T=${{ steps.create_t.outputs.issue_t }}
          MAX_WAIT=90
          ELAPSED=0
          FOUND=false

          echo "Polling for status:ready on #$ISSUE_T (max ${MAX_WAIT}s)..."
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            LABELS=$(gh api repos/$REPO/issues/$ISSUE_T --jq '.labels[].name' | tr '\n' ' ')
            if echo "$LABELS" | grep -q "status:ready"; then
              echo "✓ PASS: #$ISSUE_T has status:ready after ${ELAPSED}s"
              FOUND=true
              break
            fi
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done

          if [ "$FOUND" = false ]; then
            echo "✗ FAIL: #$ISSUE_T did not get status:ready within ${MAX_WAIT}s"
            echo "Current labels: $LABELS"
            exit 1
          fi

      # Test 2: Manual status preservation
      - name: Manually add status:in-progress to T
        run: |
          ISSUE_T=${{ steps.create_t.outputs.issue_t }}
          gh api repos/$REPO/issues/$ISSUE_T/labels -f labels[]="status:in-progress" > /dev/null
          echo "✓ Manually added status:in-progress to #$ISSUE_T"

      - name: Edit T again to trigger automation
        run: |
          ISSUE_T=${{ steps.create_t.outputs.issue_t }}
          CURRENT_BODY=$(gh api repos/$REPO/issues/$ISSUE_T --jq '.body')
          gh api repos/$REPO/issues/$ISSUE_T -f body="$CURRENT_BODY  " > /dev/null
          sleep 10
          echo "✓ Edited #$ISSUE_T again"

      - name: Verify T still has status:in-progress
        run: |
          ISSUE_T=${{ steps.create_t.outputs.issue_t }}
          LABELS=$(gh api repos/$REPO/issues/$ISSUE_T --jq '.labels[].name' | tr '\n' ' ')

          if echo "$LABELS" | grep -q "status:in-progress"; then
            echo "✓ PASS: #$ISSUE_T still has status:in-progress (not overridden)"
          else
            echo "✗ FAIL: #$ISSUE_T lost status:in-progress label"
            echo "Current labels: $LABELS"
            exit 1
          fi

      # Test 3: Feature completion tracking
      - name: Create feature F
        id: create_f
        run: |
          ISSUE_F=$(gh api repos/$REPO/issues \
            -f title="[TEST] Feature F" \
            -f body="Feature for testing completion automation" \
            -f labels[]="type:feature" \
            -f labels[]="status:feature-in-progress" \
            --jq '.number')
          echo "issue_f=$ISSUE_F" >> $GITHUB_OUTPUT
          echo "✓ Created feature issue #$ISSUE_F"

      - name: Create research child C1
        id: create_c1
        run: |
          ISSUE_F=${{ steps.create_f.outputs.issue_f }}

          BODY=$(cat <<EOF
          ### Description
          Research child C1

          ### Parent Feature Issue
          Parent Feature Issue: #$ISSUE_F
          EOF
          )

          ISSUE_C1=$(gh api repos/$REPO/issues \
            -f title="[TEST] Research C1" \
            -f body="$BODY" \
            -f labels[]="type:research" \
            --jq '.number')
          echo "issue_c1=$ISSUE_C1" >> $GITHUB_OUTPUT
          echo "✓ Created research child #$ISSUE_C1 under feature #$ISSUE_F"

      - name: Create task child C2
        id: create_c2
        run: |
          ISSUE_F=${{ steps.create_f.outputs.issue_f }}

          BODY=$(cat <<EOF
          ### Description
          Task child C2

          ### Parent Feature Issue
          Parent Feature Issue: #$ISSUE_F
          EOF
          )

          ISSUE_C2=$(gh api repos/$REPO/issues \
            -f title="[TEST] Task C2" \
            -f body="$BODY" \
            -f labels[]="type:task" \
            --jq '.number')
          echo "issue_c2=$ISSUE_C2" >> $GITHUB_OUTPUT
          echo "✓ Created task child #$ISSUE_C2 under feature #$ISSUE_F"

      - name: Close children C1 and C2
        run: |
          ISSUE_C1=${{ steps.create_c1.outputs.issue_c1 }}
          ISSUE_C2=${{ steps.create_c2.outputs.issue_c2 }}
          gh api repos/$REPO/issues/$ISSUE_C1 -f state="closed" > /dev/null
          sleep 5
          gh api repos/$REPO/issues/$ISSUE_C2 -f state="closed" > /dev/null
          echo "✓ Closed children #$ISSUE_C1 and #$ISSUE_C2"

      - name: Poll for status:done on F
        run: |
          ISSUE_F=${{ steps.create_f.outputs.issue_f }}
          MAX_WAIT=90
          ELAPSED=0
          FOUND=false

          echo "Polling for status:done on #$ISSUE_F (max ${MAX_WAIT}s)..."
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            LABELS=$(gh api repos/$REPO/issues/$ISSUE_F --jq '.labels[].name' | tr '\n' ' ')
            if echo "$LABELS" | grep -q "status:done"; then
              echo "✓ PASS: #$ISSUE_F has status:done after ${ELAPSED}s"
              FOUND=true
              break
            fi
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done

          if [ "$FOUND" = false ]; then
            echo "✗ FAIL: #$ISSUE_F did not get status:done within ${MAX_WAIT}s"
            echo "Current labels: $LABELS"
            exit 1
          fi

      - name: Poll for state:archived on C1 and C2
        run: |
          ISSUE_C1=${{ steps.create_c1.outputs.issue_c1 }}
          ISSUE_C2=${{ steps.create_c2.outputs.issue_c2 }}
          MAX_WAIT=90
          ELAPSED=0
          C1_ARCHIVED=false
          C2_ARCHIVED=false

          echo "Polling for state:archived on #$ISSUE_C1 and #$ISSUE_C2 (max ${MAX_WAIT}s)..."
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            LABELS_C1=$(gh api repos/$REPO/issues/$ISSUE_C1 --jq '.labels[].name' | tr '\n' ' ')
            LABELS_C2=$(gh api repos/$REPO/issues/$ISSUE_C2 --jq '.labels[].name' | tr '\n' ' ')

            if echo "$LABELS_C1" | grep -q "state:archived"; then
              C1_ARCHIVED=true
            fi
            if echo "$LABELS_C2" | grep -q "state:archived"; then
              C2_ARCHIVED=true
            fi

            if [ "$C1_ARCHIVED" = true ] && [ "$C2_ARCHIVED" = true ]; then
              echo "✓ PASS: Both #$ISSUE_C1 and #$ISSUE_C2 have state:archived after ${ELAPSED}s"
              break
            fi

            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done

          if [ "$C1_ARCHIVED" = false ] || [ "$C2_ARCHIVED" = false ]; then
            echo "✗ FAIL: Not all children got state:archived within ${MAX_WAIT}s"
            echo "C1 (#$ISSUE_C1) archived: $C1_ARCHIVED - labels: $LABELS_C1"
            echo "C2 (#$ISSUE_C2) archived: $C2_ARCHIVED - labels: $LABELS_C2"
            exit 1
          fi

      # Optional: Project board Stage verification
      - name: Verify Project Stage fields (if PROJECT_NUMBER set)
        if: vars.PROJECT_NUMBER != ''
        run: |
          echo "Testing Project Stage field verification..."

          ORG=$(echo $REPO | cut -d'/' -f1)

          # Get project ID
          PROJECT_ID=$(gh api graphql -f query='
            query($org: String!, $number: Int!) {
              organization(login: $org) {
                projectV2(number: $number) {
                  id
                }
              }
            }' -f org="$ORG" -F number="$PROJECT_NUMBER" --jq '.data.organization.projectV2.id')

          if [ -z "$PROJECT_ID" ]; then
            echo "⚠ Project not found, skipping Stage verification"
            exit 0
          fi

          echo "Found project ID: $PROJECT_ID"

          # Get Stage field ID and option IDs
          FIELD_DATA=$(gh api graphql -f query='
            query($projectId: ID!) {
              node(id: $projectId) {
                ... on ProjectV2 {
                  fields(first: 20) {
                    nodes {
                      ... on ProjectV2SingleSelectField {
                        id
                        name
                        options {
                          id
                          name
                        }
                      }
                    }
                  }
                }
              }
            }' -f projectId="$PROJECT_ID")

          STAGE_FIELD_ID=$(echo "$FIELD_DATA" | jq -r '.data.node.fields.nodes[] | select(.name == "Stage") | .id')

          if [ -z "$STAGE_FIELD_ID" ] || [ "$STAGE_FIELD_ID" = "null" ]; then
            echo "⚠ Stage field not found, skipping verification"
            exit 0
          fi

          echo "Found Stage field ID: $STAGE_FIELD_ID"

          # Get option IDs for Blocked, Ready, In Progress, Done
          BLOCKED_ID=$(echo "$FIELD_DATA" | jq -r '.data.node.fields.nodes[] | select(.name == "Stage") | .options[] | select(.name == "Blocked") | .id')
          READY_ID=$(echo "$FIELD_DATA" | jq -r '.data.node.fields.nodes[] | select(.name == "Stage") | .options[] | select(.name == "Ready") | .id')
          IN_PROGRESS_ID=$(echo "$FIELD_DATA" | jq -r '.data.node.fields.nodes[] | select(.name == "Stage") | .options[] | select(.name == "In Progress") | .id')
          DONE_ID=$(echo "$FIELD_DATA" | jq -r '.data.node.fields.nodes[] | select(.name == "Stage") | .options[] | select(.name == "Done") | .id')

          echo "Stage option IDs: Blocked=$BLOCKED_ID, Ready=$READY_ID, In Progress=$IN_PROGRESS_ID, Done=$DONE_ID"

          # Verify T has "In Progress" Stage (it has status:in-progress)
          ISSUE_T=${{ steps.create_t.outputs.issue_t }}
          T_ITEM=$(gh api graphql -f query='
            query($issueNumber: Int!, $repo: String!, $owner: String!) {
              repository(name: $repo, owner: $owner) {
                issue(number: $issueNumber) {
                  projectItems(first: 10) {
                    nodes {
                      project { id }
                      fieldValueByName(name: "Stage") {
                        ... on ProjectV2ItemFieldSingleSelectValue { name }
                      }
                    }
                  }
                }
              }
            }' -F issueNumber="$ISSUE_T" -f repo="$(echo $REPO | cut -d'/' -f2)" -f owner="$ORG")

          T_STAGE=$(echo "$T_ITEM" | jq -r ".data.repository.issue.projectItems.nodes[] | select(.project.id == \"$PROJECT_ID\") | .fieldValueByName.name")

          if [ "$T_STAGE" = "In Progress" ]; then
            echo "✓ PASS: Issue #$ISSUE_T has Stage='In Progress' in project"
          else
            echo "⚠ Issue #$ISSUE_T Stage is '$T_STAGE' (expected 'In Progress')"
          fi

          # Verify F has "Done" Stage
          ISSUE_F=${{ steps.create_f.outputs.issue_f }}
          F_ITEM=$(gh api graphql -f query='
            query($issueNumber: Int!, $repo: String!, $owner: String!) {
              repository(name: $repo, owner: $owner) {
                issue(number: $issueNumber) {
                  projectItems(first: 10) {
                    nodes {
                      project { id }
                      fieldValueByName(name: "Stage") {
                        ... on ProjectV2ItemFieldSingleSelectValue { name }
                      }
                    }
                  }
                }
              }
            }' -F issueNumber="$ISSUE_F" -f repo="$(echo $REPO | cut -d'/' -f2)" -f owner="$ORG")

          F_STAGE=$(echo "$F_ITEM" | jq -r ".data.repository.issue.projectItems.nodes[] | select(.project.id == \"$PROJECT_ID\") | .fieldValueByName.name")

          if [ "$F_STAGE" = "Done" ]; then
            echo "✓ PASS: Issue #$ISSUE_F has Stage='Done' in project"
          else
            echo "⚠ Issue #$ISSUE_F Stage is '$F_STAGE' (expected 'Done')"
          fi

      - name: Cleanup test issues
        if: always()
        run: |
          echo "Cleaning up test issues..."
          ISSUES="${{ steps.create_d.outputs.issue_d }} ${{ steps.create_t.outputs.issue_t }} ${{ steps.create_f.outputs.issue_f }} ${{ steps.create_c1.outputs.issue_c1 }} ${{ steps.create_c2.outputs.issue_c2 }}"
          for ISSUE in $ISSUES; do
            if [ ! -z "$ISSUE" ]; then
              gh api repos/$REPO/issues/$ISSUE -f state="closed" -f state_reason="not_planned" > /dev/null 2>&1 || true
              echo "Closed test issue #$ISSUE"
            fi
          done

      - name: Test Summary
        if: success()
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "✓ ALL TESTS PASSED"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "✓ Dependency blocking automation works"
          echo "✓ Dependency unblocking automation works"
          echo "✓ Manual status preservation works"
          echo "✓ Feature completion tracking works"
          echo "✓ Child archival automation works"
          if [ ! -z "$PROJECT_NUMBER" ]; then
            echo "✓ Project Stage field verification completed"
          fi
